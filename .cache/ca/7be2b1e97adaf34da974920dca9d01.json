{"id":"src/fragment-shader.js","dependencies":[{"name":"/Users/Arthur/Projects/Tiny/DoucheBox/client/package.json","includedInParent":true,"mtime":1561130497252}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fragmentShader = void 0;\nvar fragmentShader = \"precision highp float;\\nuniform mat4 worldView;\\nvarying vec4 vPosition;\\nvarying vec3 vNormal;\\nuniform sampler2D textureSampler;\\nuniform sampler2D backgroundVideoTexture;\\nuniform sampler2D lyricsVideoTexture;\\nuniform sampler2D camera1Texture;\\nuniform sampler2D camera2Texture;\\n\\nuniform float lyricsThreshold;\\nuniform float lyricsScale;\\nuniform float lyricsPositionX;\\nuniform float lyricsPositionY;\\n\\n// Camera 1 params\\nuniform float camera1Threshold;\\nuniform vec3 camera1ThresholdColor;\\nuniform int camera1ApplyThresholdInt;\\n\\nuniform float camera1Hue;\\nuniform float camera1Saturation;\\nuniform float camera1Brightness;\\nuniform float camera1Contrast;\\nuniform int camera1ApplyFiltersInt;\\n\\n// Camera 2 params\\nuniform float camera2Threshold;\\nuniform vec3 camera2ThresholdColor;\\nuniform int camera2ApplyThresholdInt;\\n\\nuniform float camera2Hue;\\nuniform float camera2Saturation;\\nuniform float camera2Brightness;\\nuniform float camera2Contrast;\\nuniform int camera2ApplyFiltersInt;\\n\\nuniform int applyEffectInt;\\n\\nuniform int transitionNumber;\\nuniform int effectNumber;\\nuniform float time;\\n\\nuniform float cameraSelection;\\n\\n#define NEffects 2\\n\\n#define PI 3.141592653589\\n#define POW2(X) X*X\\n#define POW3(X) X*X*X\\n#define ratio 0.5\\n\\n\\n// zoom in from 0 to 1 ; after 1 everything will be inverted,\\n// zoom out from 1 to 2, no zoom at 2, then zoom out until infinity\\n// zoom out from 0 to - infinity\\nvec2 zoom(vec2 uv, float amount) {\\n  return 0.5 + ((uv - 0.5) * (1.0-amount));\\t\\n}\\n\\nfloat rand(int num) {\\n  return fract(mod(float(num) * 67123.313, 12.0) * sin(float(num) * 10.3) * cos(float(num)));\\n}\\n\\nfloat rand (vec2 co) {\\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\\n}\\n\\nvec4 hueSaturation(vec4 color, float hue, float saturation) {\\n\\n\\tfloat angle = hue * 3.14159265;\\n\\tfloat s = sin(angle), c = cos(angle);\\n\\t\\n\\tvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\\n\\t\\n\\tfloat len = length(color.rgb);\\n\\tvec3 result = vec3( dot(color.rgb, weights.xyz), dot(color.rgb, weights.zxy), dot(color.rgb, weights.yzx) );\\n\\tfloat average = (result.r + result.g + result.b) / 3.0;\\n\\n\\tif (saturation > 0.0) {\\n\\t\\tresult += (average - result.rgb) * (1.0 - 1.0 / (1.001 - saturation));\\n\\t} else {\\n\\t\\tresult += (average - result.rgb) * (-saturation);\\n\\t}\\n\\n\\treturn vec4(result, 1.0);\\n}\\n\\nvec4 brightnessContrast(vec4 color, float brightness, float contrast) {\\n\\tvec4 result = color;\\n\\tresult += brightness;\\n\\t\\n\\tif(contrast > 0.0) {\\n\\t\\tresult.rgb += (result.rgb - 0.5) / (1.0 - contrast) + 0.5;\\n\\t} else {\\n\\t\\tresult.rgb += (result.rgb - 0.5) * (1.0 + contrast) + 0.5;\\n\\t}\\n\\treturn result;\\n}\\n\\nvec4 preprocess(vec4 color, float hue, float saturation, float brightness, float contrast) {\\n\\tvec4 result = brightnessContrast(color, brightness, contrast);\\n\\treturn hueSaturation(result, hue, saturation);\\n}\\n\\nvec4 applyThreshold(vec4 colorToThreshold, vec4 colorToApply, float cameraThreshold, vec3 cameraThresholdColor) {\\n    float distToThresholdColor = length(colorToThreshold.xyz - cameraThresholdColor.xyz);\\n    colorToApply.a = distToThresholdColor > cameraThreshold ? 1.0 : 0.0;\\n    // colorToApply.a = smoothstep(0.0, cameraThreshold, distToThresholdColor);\\n    return colorToApply;\\n}\\n\\nvec4 processCamera(vec4 color, bool applyFilters, float hue, float saturation, float brightness, float contrast, bool thresholdCamera, float cameraThreshold, vec3 cameraThresholdColor) {\\n    vec4 colorPreprocessed = (applyFilters || thresholdCamera) ? preprocess(color, hue, saturation, brightness, contrast) : color;\\n    vec4 colorThresholded = thresholdCamera ? applyThreshold(colorPreprocessed, (applyFilters ? colorPreprocessed : color), cameraThreshold, cameraThresholdColor) : colorPreprocessed;\\n    return colorThresholded;\\n}\\n\\nfloat quantizeTime(float duration, float nSteps) {\\n\\treturn floor(mod(time, duration) * nSteps / duration);\\n}\\n\\nvec4 effectJumpCut(sampler2D cameraTexture, vec2 p, bool thresholdCamera, vec3 cameraThresholdColor) {\\n\\tfloat duration = 2.5;\\n\\tfloat nSteps = 13.0;\\n\\tfloat maxZoom = 3.0;\\n\\tfloat offsetAmount = 0.5;\\n\\tfloat slideAmount = 0.2;\\n\\n\\tfloat quantizedTime = quantizeTime(duration, nSteps);\\n\\t\\n\\tfloat slideTime = slideAmount * mod(time, duration / nSteps) / (duration / nSteps);\\n\\t\\n\\tfloat quantizedTimeLong = quantizeTime(duration*nSteps, nSteps);\\n\\n\\tfloat randSeed = quantizedTimeLong + quantizedTime;\\n\\n\\tfloat rx = rand(int(randSeed));\\n\\tfloat ry = 0.0;\\n\\t// float rx = quantizedTimeLong / nSteps;\\n\\t// float ry = quantizedTime / nSteps;\\n\\n\\t// vec2 offset = vec2(rx, ry) - 0.5;\\n\\tquantizedTime += slideTime;\\n\\n\\tquantizedTime /= nSteps;\\n\\tquantizedTime = 1.0 - quantizedTime;\\n\\tvec2 offset = offsetAmount * quantizedTime * (vec2(rx, ry) - 0.5);\\n\\n\\tquantizedTime *= maxZoom;\\n\\t// return texture2D(cameraTexture, p * quantizedTime + offset);\\n\\t\\n\\tp.y += 0.5 * quantizedTime / maxZoom;\\n\\tvec2 pCentered = p-0.5;\\n\\tvec2 newPositionCentered = pCentered * quantizedTime + offset;\\n\\tvec2 newPosition = newPositionCentered + 0.5;\\n\\t\\n\\tbool outside = abs(newPositionCentered.x) > 0.5 || abs(newPositionCentered.y) > 0.5;\\n\\t\\n\\tvec4 backgroundColor = thresholdCamera ? vec4(cameraThresholdColor, 1.0) : vec4(0.0);\\n\\treturn outside ? backgroundColor : texture2D(cameraTexture, newPosition);\\n}\\n\\nfloat toBezier(float t, vec2 P1, vec2 P2) {\\n\\tvec2 P0 = vec2(0.0, 0.0);\\n\\tvec2 P3 = vec2(1.0, 1.0);\\n    float t2 = t * t;\\n    float one_minus_t = 1.0 - t;\\n    float one_minus_t2 = one_minus_t * one_minus_t;\\n    return (P0 * one_minus_t2 * one_minus_t + P1 * 3.0 * t * one_minus_t2 + P2 * 3.0 * t2 * one_minus_t + P3 * t2 * t).y;\\n}\\n\\nfloat toBezier(float t, float p1x, float p1y, float p2x, float p2y) {\\n\\treturn toBezier(t, vec2(p1x, p1y), vec2(p2x, p2y));\\n}\\n\\nvec4 effectZoom(sampler2D cameraTexture, vec2 p, bool thresholdCamera) {\\n\\tfloat duration = 1.5;\\n\\tfloat t = mod(time, duration) / duration;\\n\\tfloat zoomMin = -1.5;\\n\\tfloat zoomMax = 0.5;\\n\\tfloat zoomAmplitude = zoomMax - zoomMin;\\n\\t// float amount = zoomAmplitude * toBezier(t, .71,.16,.48,1.72) + zoomMin;\\n\\tfloat amount = zoomAmplitude * toBezier(t, .73,1.44,.7,1.51) / 1.3 + zoomMin;\\n\\t\\n\\tvec2 pZoomed = zoom(p, amount);\\n\\treturn texture2D(cameraTexture, pZoomed);\\n}\\n\\nvec4 applyEffect(sampler2D cameraTexture, vec2 p, bool thresholdCamera, vec3 cameraThresholdColor) {\\n\\tvec4 color = vec4(0.0);\\n\\tif (applyEffectInt > 0 && effectNumber < NEffects) {\\n\\t\\tif(effectNumber == 0) {\\n\\t\\t\\tcolor = effectJumpCut(cameraTexture, p, thresholdCamera, cameraThresholdColor);\\n\\t\\t} else if(effectNumber == 1) {\\n\\t\\t\\tcolor = effectZoom(cameraTexture, p, thresholdCamera);\\n\\t\\t}\\n\\t} else {\\n\\t\\tcolor = texture2D(cameraTexture, p);\\n\\t}\\n\\treturn  color;\\n}\\n\\nvec4 getFromColor(vec2 uv) {\\n\\tbool thresholdCamera = camera1ApplyThresholdInt > 0;\\n\\tbool applyFilter = camera1ApplyFiltersInt > 0;\\n    vec4 camera1 = applyEffect(camera1Texture, uv, thresholdCamera, camera1ThresholdColor);\\n    vec4 camera1Processed = processCamera(camera1, applyFilter, camera1Hue, camera1Saturation, camera1Brightness, camera1Contrast, thresholdCamera, camera1Threshold, camera1ThresholdColor);\\n    return camera1Processed;\\n}\\n\\nvec4 getToColor(vec2 uv) {\\n\\tbool thresholdCamera = camera2ApplyThresholdInt > 0;\\n\\tbool applyFilter = camera2ApplyFiltersInt > 0;\\n    vec4 camera2 = applyEffect(camera2Texture, uv, thresholdCamera, camera2ThresholdColor);\\n    vec4 camera2Processed = processCamera(camera2, applyFilter, camera2Hue, camera2Saturation, camera2Brightness, camera2Contrast, thresholdCamera, camera1Threshold, camera2ThresholdColor);\\n    return camera2Processed;\\n}\\n\\n\\nvec4 zoomTransition(vec2 uv) {\\n\\tfloat zoom_quickness = 0.8;\\n\\tfloat nQuick = clamp(zoom_quickness, 0.2, 1.0);\\n\\treturn mix(\\n\\t\\tgetFromColor(zoom(uv, smoothstep(0.0, nQuick, cameraSelection))),\\n\\t\\tgetToColor(uv),\\n\\t\\tsmoothstep(nQuick - 0.2, 1.0, cameraSelection)\\n\\t);\\n}\\n\\nvec4 transitionDirectional(vec2 uv, vec2 direction) {\\n\\tvec2 p = uv + cameraSelection * sign(direction);\\n\\tvec2 f = fract(p);\\n\\treturn mix(\\n\\t\\tgetToColor(f),\\n\\t\\tgetFromColor(f),\\n\\t\\tstep(0.0, p.y) * step(p.y, 1.0) * step(0.0, p.x) * step(p.x, 1.0)\\n\\t);\\n}\\n\\nvec4 transitionSlice (vec2 p, float count, float smoothness) {\\n  float pr = smoothstep(-smoothness, 0.0, p.x - cameraSelection * (1.0 + smoothness));\\n  float s = step(pr, fract(count * p.x));\\n  return mix(getFromColor(p), getToColor(p), s);\\n}\\n\\nvec4 transitionWaterDrop(vec2 p, float amplitude, float speed) {\\n  vec2 dir = p - vec2(.5);\\n  float dist = length(dir);\\n\\n  if (dist > cameraSelection) {\\n    return mix(getFromColor( p), getToColor( p), cameraSelection);\\n  } else {\\n    vec2 offset = dir * sin(dist * amplitude - cameraSelection * speed);\\n    return mix(getFromColor( p + offset), getToColor( p), cameraSelection);\\n  }\\n}\\n\\n\\nfloat wave(int num, float frequency, int bars) {\\n  float fn = float(num) * frequency * 0.1 * float(bars);\\n  return cos(fn * 0.5) * cos(fn * 0.13) * sin((fn+10.0) * 0.3) / 2.0 + 0.5;\\n}\\n\\nfloat drip(int num, int bars, float dripScale) {\\n  return sin(float(num) / float(bars - 1) * 3.141592) * dripScale;\\n}\\n\\nfloat pos(int num, float noise, float frequency, int bars, float dripScale) {\\n  return (noise == 0.0 ? wave(num, frequency, bars) : mix(wave(num, frequency, bars), rand(num), noise)) + (dripScale == 0.0 ? 0.0 : drip(num, bars, dripScale));\\n}\\n\\nvec4 transitionBars(vec2 uv, int bars, float amplitude, float noise, float frequency, float dripScale) {\\n\\n  int bar = int(uv.x * (float(bars)));\\n  float scale = 1.0 + pos(bar, noise, frequency, bars, dripScale) * amplitude;\\n  float phase = cameraSelection * scale;\\n  float posY = uv.y / vec2(1.0).y;\\n  vec2 p;\\n  vec4 c;\\n  if (phase + posY < 1.0) {\\n    p = vec2(uv.x, uv.y + mix(0.0, vec2(1.0).y, phase)) / vec2(1.0).xy;\\n    c = getFromColor(p);\\n  } else {\\n    p = uv.xy / vec2(1.0).xy;\\n    c = getToColor(p);\\n  }\\n\\n  // Finally, apply the color\\n  return c;\\n}\\n\\n\\nvec4 transitionPinWheel(vec2 uv, float speed) {\\n  \\n  vec2 p = uv.xy / vec2(1.0).xy;\\n  \\n  float circPos = atan(p.y - 0.5, p.x - 0.5) + cameraSelection * speed;\\n  float modPos = mod(circPos, 3.1415 / 4.);\\n  float signed = sign(cameraSelection - modPos);\\n  \\n  return mix(getToColor(p), getFromColor(p), step(signed, 0.5));\\n  \\n}\\n\\nvec4 transitionAngular (vec2 uv, float startingAngle) {\\n  \\n  float offset = startingAngle * PI / 180.0;\\n  float angle = atan(uv.y - 0.5, uv.x - 0.5) + offset;\\n  float normalizedAngle = (angle + PI) / (2.0 * PI);\\n  \\n  normalizedAngle = normalizedAngle - floor(normalizedAngle);\\n\\n  return mix(\\n    getFromColor(uv),\\n    getToColor(uv),\\n    step(normalizedAngle, cameraSelection)\\n    );\\n}\\n\\nvec4 transitionColorPhase(vec2 uv) {\\n\\tvec4 fromStep = vec4(0.0, 0.2, 0.4, 0.0);\\n\\tvec4 toStep = vec4(0.6, 0.8, 1.0, 1.0);\\n\\n\\tvec4 a = getFromColor(uv);\\n\\tvec4 b = getToColor(uv);\\n\\treturn mix(a, b, smoothstep(fromStep, toStep, vec4(cameraSelection)));\\n}\\n\\nvec4 transitionCircle(vec2 uv) {\\n  \\n  vec2 center = vec2(0.5, 0.5);\\n  vec3 backColor = vec3(0.1, 0.1, 0.1);\\n\\n  float distance = length(uv - center);\\n  float radius = sqrt(8.0) * abs(cameraSelection - 0.5);\\n  \\n  if (distance > radius) {\\n    return vec4(backColor, 1.0);\\n  }\\n  else {\\n    if (cameraSelection < 0.5) return getFromColor(uv);\\n    else return getToColor(uv);\\n  }\\n}\\n\\n\\nvec2 project (vec2 p, float floating) {\\n  return p * vec2(1.0, -1.2) + vec2(0.0, -floating/100.);\\n}\\n\\nbool inBounds (vec2 p) {\\n  return all(lessThan(vec2(0.0), p)) && all(lessThan(p, vec2(1.0)));\\n}\\n\\nvec4 bgColor (vec2 p, vec2 pfr, vec2 pto, float reflection, float floating) {\\n  vec4 c = vec4(0.0, 0.0, 0.0, 1.0);\\n  pfr = project(pfr, floating);\\n  // FIXME avoid branching might help perf!\\n  if (inBounds(pfr)) {\\n    c += mix(vec4(0.0), getFromColor(pfr), reflection * mix(1.0, 0.0, pfr.y));\\n  }\\n  pto = project(pto, floating);\\n  if (inBounds(pto)) {\\n    c += mix(vec4(0.0), getToColor(pto), reflection * mix(1.0, 0.0, pto.y));\\n  }\\n  return c;\\n}\\n\\n// p : the position\\n// persp : the perspective in [ 0, 1 ]\\n// center : the xcenter in [0, 1]  0.5 excluded\\nvec2 xskew (vec2 p, float persp, float center) {\\n  float x = mix(p.x, 1.0-p.x, center);\\n  return (\\n    (\\n      vec2( x, (p.y - 0.5*(1.0-persp) * x) / (1.0+(persp-1.0)*x) )\\n      - vec2(0.5-distance(center, 0.5), 0.0)\\n    )\\n    * vec2(0.5 / distance(center, 0.5) * (center<0.5 ? 1.0 : -1.0), 1.0)\\n    + vec2(center<0.5 ? 0.0 : 1.0, 0.0)\\n  );\\n}\\n\\nvec4 transitionCube(vec2 op) {\\n\\n  float persp = 0.7;\\n  float unzoom = 0.3;\\n  float reflection = 0.4;\\n  float floating = 3.0;\\n\\n  float uz = unzoom * 2.0*(0.5-distance(0.5, cameraSelection));\\n  vec2 p = -uz*0.5+(1.0+uz) * op;\\n  vec2 fromP = xskew(\\n    (p - vec2(cameraSelection, 0.0)) / vec2(1.0-cameraSelection, 1.0),\\n    1.0-mix(cameraSelection, 0.0, persp),\\n    0.0\\n  );\\n  vec2 toP = xskew(\\n    p / vec2(cameraSelection, 1.0),\\n    mix(pow(cameraSelection, 2.0), 1.0, persp),\\n    1.0\\n  );\\n  // FIXME avoid branching might help perf!\\n  if (inBounds(fromP)) {\\n    return getFromColor(fromP);\\n  }\\n  else if (inBounds(toP)) {\\n    return getToColor(toP);\\n  }\\n  return bgColor(op, fromP, toP, reflection, floating);\\n}\\n\\n\\nvec2 project2 (vec2 p) {\\n  return p * vec2(1.0, -1.2) + vec2(0.0, -0.02);\\n}\\n\\nvec4 bgColor (vec2 p, vec2 pto, float reflection) {\\n  vec4 c = vec4(0.0);\\n  pto = project2(pto);\\n  if (inBounds(pto)) {\\n    c += mix(c, getToColor(pto), reflection * mix(1.0, 0.0, pto.y));\\n  }\\n  return c;\\n}\\n\\n\\nvec4 transitionDoorWay (vec2 p) {\\n\\n  float reflection = 0.4;\\n  float perspective = 0.4;\\n  float depth = 3.0;\\n\\n  const vec4 black = vec4(0.0, 0.0, 0.0, 0.0);\\n  const vec2 boundMin = vec2(0.0, 0.0);\\n  const vec2 boundMax = vec2(1.0, 1.0);\\n\\n  vec2 pfr = vec2(-1.), pto = vec2(-1.);\\n  float middleSlit = 2.0 * abs(p.x-0.5) - cameraSelection;\\n  if (middleSlit > 0.0) {\\n    pfr = p + (p.x > 0.5 ? -1.0 : 1.0) * vec2(0.5*cameraSelection, 0.0);\\n    float d = 1.0/(1.0+perspective*cameraSelection*(1.0-middleSlit));\\n    pfr.y -= d/2.;\\n    pfr.y *= d;\\n    pfr.y += d/2.;\\n  }\\n  float size = mix(1.0, depth, 1.-cameraSelection);\\n  pto = (p + vec2(-0.5, -0.5)) * vec2(size, size) + vec2(0.5, 0.5);\\n  if (inBounds(pfr)) {\\n    return getFromColor(pfr);\\n  }\\n  else if (inBounds(pto)) {\\n    return getToColor(pto);\\n  }\\n  else {\\n    return bgColor(p, pto, reflection);\\n  }\\n}\\n\\nfloat inHeart (vec2 p, vec2 center, float size) {\\n  if (size==0.0) return 0.0;\\n  vec2 o = (p-center)/(1.6*size);\\n  float a = o.x*o.x+o.y*o.y-0.3;\\n  return step(a*a*a, o.x*o.x*o.y*o.y*o.y);\\n}\\n\\nvec4 transitionHeart (vec2 uv) {\\n  return mix(\\n    getFromColor(uv),\\n    getToColor(uv),\\n    inHeart(uv, vec2(0.5, 0.4), cameraSelection)\\n  );\\n}\\n\\n\\nvec4 transitionPixelize(vec2 uv) {\\n\\n  int steps = 50; // zero disable the stepping\\n  ivec2 squaresMin = ivec2(20); // minimum number of squares (when the effect is at its higher level)\\n  float d = min(cameraSelection, 1.0 - cameraSelection);\\n  float dist = steps>0 ? ceil(d * float(steps)) / float(steps) : d;\\n  vec2 squareSize = 2.0 * dist / vec2(squaresMin);\\n  \\n  \\n\\n  vec2 p = dist>0.0 ? (floor(uv / squareSize) + 0.5) * squareSize : uv;\\n  return mix(getFromColor(p), getToColor(p), cameraSelection);\\n}\\n\\n\\nvec4 transitionRotateScaleFade(vec2 uv) {\\n  \\n  vec2 center = vec2(0.5, 0.5);\\n  float rotations = 1.0;\\n  float scale = 8.0;\\n  vec4 backColor = vec4(0.15, 0.15, 0.15, 1.0);\\n\\n  vec2 difference = uv - center;\\n  vec2 dir = normalize(difference);\\n  float dist = length(difference);\\n  \\n  float angle = 2.0 * PI * rotations * cameraSelection;\\n  \\n  float c = cos(angle);\\n  float s = sin(angle);\\n  \\n  float currentScale = mix(scale, 1.0, 2.0 * abs(cameraSelection - 0.5));\\n  \\n  vec2 rotatedDir = vec2(dir.x  * c - dir.y * s, dir.x * s + dir.y * c);\\n  vec2 rotatedUv = center + rotatedDir * dist / currentScale;\\n  \\n  if (rotatedUv.x < 0.0 || rotatedUv.x > 1.0 ||\\n      rotatedUv.y < 0.0 || rotatedUv.y > 1.0)\\n    return backColor;\\n    \\n  return mix(getFromColor(rotatedUv), getToColor(rotatedUv), cameraSelection);\\n}\\n\\n\\nvec4 transitionCircleCrop(vec2 p) {\\n  vec2 ratio2 = vec2(1.0, 1.0 / 0.5);\\n  float s = pow(2.0 * abs(cameraSelection - 0.5), 3.0);\\n  vec4 bgcolor = vec4(0.0, 0.0, 0.0, 1.0);\\n  float dist = length((vec2(p) - 0.5) * ratio2);\\n  return mix(\\n    cameraSelection < 0.5 ? getFromColor(p) : getToColor(p), // branching is ok here as we statically depend on cameraSelection uniform (branching won't change over pixels)\\n    bgcolor,\\n    step(s, dist)\\n  );\\n}\\n\\nvec4 transitionColorDistance(vec2 p) {\\n  float power = 5.0;\\n  vec4 fTex = getFromColor(p);\\n  vec4 tTex = getToColor(p);\\n  float m = step(distance(fTex, tTex), cameraSelection);\\n  return mix(\\n    mix(fTex, tTex, m),\\n    tTex,\\n    pow(cameraSelection, power)\\n  );\\n}\\n\\nvec4 transitionSwirl(vec2 UV)\\n{\\n\\tfloat Radius = 1.0;\\n\\n\\tfloat T = cameraSelection;\\n\\n\\tUV -= vec2( 0.5, 0.5 );\\n\\n\\tfloat Dist = length(UV);\\n\\n\\tif ( Dist < Radius )\\n\\t{\\n\\t\\tfloat Percent = (Radius - Dist) / Radius;\\n\\t\\tfloat A = ( T <= 0.5 ) ? mix( 0.0, 1.0, T/0.5 ) : mix( 1.0, 0.0, (T-0.5)/0.5 );\\n\\t\\tfloat Theta = Percent * Percent * A * 8.0 * 3.14159;\\n\\t\\tfloat S = sin( Theta );\\n\\t\\tfloat C = cos( Theta );\\n\\t\\tUV = vec2( dot(UV, vec2(C, -S)), dot(UV, vec2(S, C)) );\\n\\t}\\n\\tUV += vec2( 0.5, 0.5 );\\n\\n\\tvec4 C0 = getFromColor(UV);\\n\\tvec4 C1 = getToColor(UV);\\n\\n\\treturn mix( C0, C1, T );\\n}\\n\\nvec2 offset(float cameraSelection, float x, float theta) {\\n  float phase = cameraSelection*cameraSelection + cameraSelection + theta;\\n  float shifty = 0.03*cameraSelection*cos(10.0*(cameraSelection+x));\\n  return vec2(0, shifty);\\n}\\nvec4 transitionDreamy(vec2 p) {\\n  return mix(getFromColor(p + offset(cameraSelection, p.x, 0.0)), getToColor(p + offset(1.0-cameraSelection, p.x, 3.14)), cameraSelection);\\n}\\n\\n\\nfloat Linear_ease(in float begin, in float change, in float duration, in float easeTime) {\\n    return change * easeTime / duration + begin;\\n}\\n\\nfloat Exponential_easeInOut(in float begin, in float change, in float duration, in float easeTime) {\\n    if (easeTime == 0.0)\\n        return begin;\\n    else if (easeTime == duration)\\n        return begin + change;\\n    easeTime = easeTime / (duration / 2.0);\\n    if (easeTime < 1.0)\\n        return change / 2.0 * pow(2.0, 10.0 * (easeTime - 1.0)) + begin;\\n    return change / 2.0 * (-pow(2.0, -10.0 * (easeTime - 1.0)) + 2.0) + begin;\\n}\\n\\nfloat Sinusoidal_easeInOut(in float begin, in float change, in float duration, in float easeTime) {\\n    return -change / 2.0 * (cos(PI * easeTime / duration) - 1.0) + begin;\\n}\\n\\n\\nvec3 crossFade(in vec2 uv, in float dissolve) {\\n    return mix(getFromColor(uv).rgb, getToColor(uv).rgb, dissolve);\\n}\\n\\nvec4 transitionCrossZoom(vec2 uv) {\\n\\tfloat strength = 0.4;\\n    vec2 texCoord = uv.xy / vec2(1.0).xy;\\n\\n    // Linear interpolate center across center half of the image\\n    vec2 center = vec2(Linear_ease(0.25, 0.5, 1.0, cameraSelection), 0.5);\\n    float dissolve = Exponential_easeInOut(0.0, 1.0, 1.0, cameraSelection);\\n\\n    // Mirrored sinusoidal loop. 0->strength then strength->0\\n    float strength2 = Sinusoidal_easeInOut(0.0, strength, 0.5, cameraSelection);\\n\\n    vec3 color = vec3(0.0);\\n    float total = 0.0;\\n    vec2 toCenter = center - texCoord;\\n\\n    /* randomize the lookup values to hide the fixed number of samples */\\n    float offset = rand(uv);\\n\\n    for (float t = 0.0; t <= 40.0; t++) {\\n        float percent = (t + offset) / 40.0;\\n        float weight = 4.0 * (percent - percent * percent);\\n        color += crossFade(texCoord + toCenter * percent * strength2, dissolve) * weight;\\n        total += weight;\\n    }\\n    return vec4(color / total, 1.0);\\n}\\n\\n\\nfloat Rand(vec2 v) {\\n  return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453);\\n}\\n\\nvec2 Rotate(vec2 v, float a) {\\n  mat2 rm = mat2(cos(a), -sin(a),\\n                 sin(a), cos(a));\\n  return rm*v;\\n}\\nfloat CosInterpolation(float x) {\\n  return -cos(x*PI)/2.+.5;\\n}\\n\\nvec4 transitionMosaic(vec2 uv) {\\n  int endx = 2;\\n  int endy = -1;\\n  vec2 p = uv.xy / vec2(1.0).xy - .5;\\n  vec2 rp = p;\\n  float rpr = (cameraSelection*2.-1.);\\n  float z = -(rpr*rpr*2.) + 3.;\\n  float az = abs(z);\\n  rp *= az;\\n  rp += mix(vec2(.5, .5), vec2(float(endx) + .5, float(endy) + .5), POW2(CosInterpolation(cameraSelection)));\\n  vec2 mrp = mod(rp, 1.);\\n  vec2 crp = rp;\\n  bool onEnd = int(floor(crp.x))==endx&&int(floor(crp.y))==endy;\\n  if(!onEnd) {\\n    float ang = float(int(Rand(floor(crp))*4.))*.5*PI;\\n    mrp = vec2(.5) + Rotate(mrp-vec2(.5), ang);\\n  }\\n  if(onEnd || Rand(floor(crp))>.5) {\\n    return getToColor(mrp);\\n  } else {\\n    return getFromColor(mrp);\\n  }\\n}\\n\\nvec4 transitionRadial(vec2 p) {\\n  float smoothness = 1.0;\\n  vec2 rp = p*2.-1.;\\n  return mix(\\n    getToColor(p),\\n    getFromColor(p),\\n    smoothstep(0., smoothness, atan(rp.y,rp.x) - (cameraSelection-.5) * PI * 2.5)\\n  );\\n}\\n\\n\\nvoid main() {\\n\\tvec2 uv = vPosition.xy + 0.5;\\n\\n\\tvec4 lyricsBackgroundColor = texture2D(lyricsVideoTexture, vec2(0.0, 0.0));\\n\\n\\tvec2 lyricsPosition = uv - 0.5;\\n\\tlyricsPosition -= vec2(lyricsPositionX, lyricsPositionY);\\n\\tlyricsPosition /= lyricsScale;\\n\\tbool lyricsOutside = abs(lyricsPosition.x) > 0.5 || abs(lyricsPosition.y) > 0.5;\\n\\tlyricsPosition += 0.5;\\n\\tvec4 lyricsColor = lyricsOutside ? lyricsBackgroundColor : texture2D(lyricsVideoTexture, lyricsPosition);\\n\\tvec4 background = texture2D(backgroundVideoTexture, uv);\\n\\n\\tvec4 cameraColor = vec4(0.0);\\n\\tif(transitionNumber == 0) {\\n\\t\\tcameraColor = zoomTransition(uv);\\n\\t} else if(transitionNumber == 1) {\\n\\t\\tcameraColor = transitionDirectional(uv, vec2(1.0, 0.0));\\n\\t} else if(transitionNumber == 2) {\\n\\t\\tcameraColor = transitionDirectional(uv, vec2(0.0, 1.0));\\n\\t} else if(transitionNumber == 3) {\\n\\t\\tcameraColor = transitionDirectional(uv, vec2(0.5, 0.5));\\n\\t} else if(transitionNumber == 4) {\\n\\t\\tcameraColor = transitionSlice(uv, 10.0, 0.5);\\n\\t} else if(transitionNumber == 5) {\\n\\t\\tcameraColor = transitionSlice(uv, 25.0, 1.0);\\n\\t} else if(transitionNumber == 6) {\\n\\t\\tcameraColor = transitionWaterDrop(uv, 30.0, 30.0);\\n\\t} else if(transitionNumber == 7) {\\n\\t\\tcameraColor = transitionWaterDrop(uv, 10.0, 60.0);\\n\\t} else if(transitionNumber == 8) {\\n\\t\\tcameraColor = transitionHeart(uv);\\n\\t} else if(transitionNumber == 9) {\\n\\t\\tcameraColor = transitionBars(uv, 30, 2.0, 0.1, 0.5, 0.5);\\n\\t} else if(transitionNumber == 10) {\\n\\t\\tcameraColor = transitionBars(uv, 60, 1.0, 0.5, 0.15, 0.85);\\n\\t} else if(transitionNumber == 11) {\\n\\t\\tcameraColor = transitionPinWheel(uv, 2.0);\\n\\t} else if(transitionNumber == 12) {\\n\\t\\tcameraColor = transitionAngular(uv, 90.0);\\n\\t} else if(transitionNumber == 13) {\\n\\t\\tcameraColor = transitionColorPhase(uv);\\n\\t} else if(transitionNumber == 14) {\\n\\t\\tcameraColor = transitionCircle(uv);\\n\\t} else if(transitionNumber == 15) {\\n\\t\\tcameraColor = transitionCube(uv);\\n\\t} else if(transitionNumber == 16) {\\n\\t\\tcameraColor = transitionDoorWay(uv);\\n\\t} else if(transitionNumber == 17) {\\n\\t\\tcameraColor = transitionHeart(uv);\\n\\t}  else if(transitionNumber == 18) {\\n\\t\\tcameraColor = transitionPixelize(uv);\\n\\t}  else if(transitionNumber == 19) {\\n\\t\\tcameraColor = transitionRotateScaleFade(uv);\\n\\t}  else if(transitionNumber == 20) {\\n\\t\\tcameraColor = transitionCircleCrop(uv);\\n\\t}  else if(transitionNumber == 21) {\\n\\t\\tcameraColor = transitionColorDistance(uv);\\n\\t}  else if(transitionNumber == 22) {\\n\\t\\tcameraColor = transitionSwirl(uv);\\n\\t}  else if(transitionNumber == 23) {\\n\\t\\tcameraColor = transitionDreamy(uv);\\n\\t}  else if(transitionNumber == 24) {\\n\\t\\tcameraColor = transitionCrossZoom(uv);\\n\\t}  else if(transitionNumber == 25) {\\n\\t\\tcameraColor = transitionMosaic(uv);\\n\\t}  else if(transitionNumber == 26) {\\n\\t\\tcameraColor = transitionRadial(uv);\\n\\t} else {\\n        discard;\\n\\t}\\n\\n\\tvec4 cameraBackgroundColor = mix(background, cameraColor, cameraColor.a);\\n\\n\\tfloat lyricsDistToBackground = length(lyricsColor.xyz - lyricsBackgroundColor.xyz);\\n\\tgl_FragColor = lyricsDistToBackground > lyricsThreshold ? lyricsColor : cameraBackgroundColor;\\n\\t// gl_FragColor = cameraColor;\\n}\";\nexports.fragmentShader = fragmentShader;"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":7,"column":0},"source":"src/fragment-shader.js","original":{"line":1,"column":7}},{"name":"fragmentShader","generated":{"line":7,"column":4},"source":"src/fragment-shader.js","original":{"line":1,"column":11}},{"generated":{"line":7,"column":18},"source":"src/fragment-shader.js","original":{"line":1,"column":25}},{"generated":{"line":7,"column":24447},"source":"src/fragment-shader.js","original":{"line":1,"column":7}}],"sources":{"src/fragment-shader.js":"export var fragmentShader = `precision highp float;\nuniform mat4 worldView;\nvarying vec4 vPosition;\nvarying vec3 vNormal;\nuniform sampler2D textureSampler;\nuniform sampler2D backgroundVideoTexture;\nuniform sampler2D lyricsVideoTexture;\nuniform sampler2D camera1Texture;\nuniform sampler2D camera2Texture;\n\nuniform float lyricsThreshold;\nuniform float lyricsScale;\nuniform float lyricsPositionX;\nuniform float lyricsPositionY;\n\n// Camera 1 params\nuniform float camera1Threshold;\nuniform vec3 camera1ThresholdColor;\nuniform int camera1ApplyThresholdInt;\n\nuniform float camera1Hue;\nuniform float camera1Saturation;\nuniform float camera1Brightness;\nuniform float camera1Contrast;\nuniform int camera1ApplyFiltersInt;\n\n// Camera 2 params\nuniform float camera2Threshold;\nuniform vec3 camera2ThresholdColor;\nuniform int camera2ApplyThresholdInt;\n\nuniform float camera2Hue;\nuniform float camera2Saturation;\nuniform float camera2Brightness;\nuniform float camera2Contrast;\nuniform int camera2ApplyFiltersInt;\n\nuniform int applyEffectInt;\n\nuniform int transitionNumber;\nuniform int effectNumber;\nuniform float time;\n\nuniform float cameraSelection;\n\n#define NEffects 2\n\n#define PI 3.141592653589\n#define POW2(X) X*X\n#define POW3(X) X*X*X\n#define ratio 0.5\n\n\n// zoom in from 0 to 1 ; after 1 everything will be inverted,\n// zoom out from 1 to 2, no zoom at 2, then zoom out until infinity\n// zoom out from 0 to - infinity\nvec2 zoom(vec2 uv, float amount) {\n  return 0.5 + ((uv - 0.5) * (1.0-amount));\t\n}\n\nfloat rand(int num) {\n  return fract(mod(float(num) * 67123.313, 12.0) * sin(float(num) * 10.3) * cos(float(num)));\n}\n\nfloat rand (vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 hueSaturation(vec4 color, float hue, float saturation) {\n\n\tfloat angle = hue * 3.14159265;\n\tfloat s = sin(angle), c = cos(angle);\n\t\n\tvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\n\t\n\tfloat len = length(color.rgb);\n\tvec3 result = vec3( dot(color.rgb, weights.xyz), dot(color.rgb, weights.zxy), dot(color.rgb, weights.yzx) );\n\tfloat average = (result.r + result.g + result.b) / 3.0;\n\n\tif (saturation > 0.0) {\n\t\tresult += (average - result.rgb) * (1.0 - 1.0 / (1.001 - saturation));\n\t} else {\n\t\tresult += (average - result.rgb) * (-saturation);\n\t}\n\n\treturn vec4(result, 1.0);\n}\n\nvec4 brightnessContrast(vec4 color, float brightness, float contrast) {\n\tvec4 result = color;\n\tresult += brightness;\n\t\n\tif(contrast > 0.0) {\n\t\tresult.rgb += (result.rgb - 0.5) / (1.0 - contrast) + 0.5;\n\t} else {\n\t\tresult.rgb += (result.rgb - 0.5) * (1.0 + contrast) + 0.5;\n\t}\n\treturn result;\n}\n\nvec4 preprocess(vec4 color, float hue, float saturation, float brightness, float contrast) {\n\tvec4 result = brightnessContrast(color, brightness, contrast);\n\treturn hueSaturation(result, hue, saturation);\n}\n\nvec4 applyThreshold(vec4 colorToThreshold, vec4 colorToApply, float cameraThreshold, vec3 cameraThresholdColor) {\n    float distToThresholdColor = length(colorToThreshold.xyz - cameraThresholdColor.xyz);\n    colorToApply.a = distToThresholdColor > cameraThreshold ? 1.0 : 0.0;\n    // colorToApply.a = smoothstep(0.0, cameraThreshold, distToThresholdColor);\n    return colorToApply;\n}\n\nvec4 processCamera(vec4 color, bool applyFilters, float hue, float saturation, float brightness, float contrast, bool thresholdCamera, float cameraThreshold, vec3 cameraThresholdColor) {\n    vec4 colorPreprocessed = (applyFilters || thresholdCamera) ? preprocess(color, hue, saturation, brightness, contrast) : color;\n    vec4 colorThresholded = thresholdCamera ? applyThreshold(colorPreprocessed, (applyFilters ? colorPreprocessed : color), cameraThreshold, cameraThresholdColor) : colorPreprocessed;\n    return colorThresholded;\n}\n\nfloat quantizeTime(float duration, float nSteps) {\n\treturn floor(mod(time, duration) * nSteps / duration);\n}\n\nvec4 effectJumpCut(sampler2D cameraTexture, vec2 p, bool thresholdCamera, vec3 cameraThresholdColor) {\n\tfloat duration = 2.5;\n\tfloat nSteps = 13.0;\n\tfloat maxZoom = 3.0;\n\tfloat offsetAmount = 0.5;\n\tfloat slideAmount = 0.2;\n\n\tfloat quantizedTime = quantizeTime(duration, nSteps);\n\t\n\tfloat slideTime = slideAmount * mod(time, duration / nSteps) / (duration / nSteps);\n\t\n\tfloat quantizedTimeLong = quantizeTime(duration*nSteps, nSteps);\n\n\tfloat randSeed = quantizedTimeLong + quantizedTime;\n\n\tfloat rx = rand(int(randSeed));\n\tfloat ry = 0.0;\n\t// float rx = quantizedTimeLong / nSteps;\n\t// float ry = quantizedTime / nSteps;\n\n\t// vec2 offset = vec2(rx, ry) - 0.5;\n\tquantizedTime += slideTime;\n\n\tquantizedTime /= nSteps;\n\tquantizedTime = 1.0 - quantizedTime;\n\tvec2 offset = offsetAmount * quantizedTime * (vec2(rx, ry) - 0.5);\n\n\tquantizedTime *= maxZoom;\n\t// return texture2D(cameraTexture, p * quantizedTime + offset);\n\t\n\tp.y += 0.5 * quantizedTime / maxZoom;\n\tvec2 pCentered = p-0.5;\n\tvec2 newPositionCentered = pCentered * quantizedTime + offset;\n\tvec2 newPosition = newPositionCentered + 0.5;\n\t\n\tbool outside = abs(newPositionCentered.x) > 0.5 || abs(newPositionCentered.y) > 0.5;\n\t\n\tvec4 backgroundColor = thresholdCamera ? vec4(cameraThresholdColor, 1.0) : vec4(0.0);\n\treturn outside ? backgroundColor : texture2D(cameraTexture, newPosition);\n}\n\nfloat toBezier(float t, vec2 P1, vec2 P2) {\n\tvec2 P0 = vec2(0.0, 0.0);\n\tvec2 P3 = vec2(1.0, 1.0);\n    float t2 = t * t;\n    float one_minus_t = 1.0 - t;\n    float one_minus_t2 = one_minus_t * one_minus_t;\n    return (P0 * one_minus_t2 * one_minus_t + P1 * 3.0 * t * one_minus_t2 + P2 * 3.0 * t2 * one_minus_t + P3 * t2 * t).y;\n}\n\nfloat toBezier(float t, float p1x, float p1y, float p2x, float p2y) {\n\treturn toBezier(t, vec2(p1x, p1y), vec2(p2x, p2y));\n}\n\nvec4 effectZoom(sampler2D cameraTexture, vec2 p, bool thresholdCamera) {\n\tfloat duration = 1.5;\n\tfloat t = mod(time, duration) / duration;\n\tfloat zoomMin = -1.5;\n\tfloat zoomMax = 0.5;\n\tfloat zoomAmplitude = zoomMax - zoomMin;\n\t// float amount = zoomAmplitude * toBezier(t, .71,.16,.48,1.72) + zoomMin;\n\tfloat amount = zoomAmplitude * toBezier(t, .73,1.44,.7,1.51) / 1.3 + zoomMin;\n\t\n\tvec2 pZoomed = zoom(p, amount);\n\treturn texture2D(cameraTexture, pZoomed);\n}\n\nvec4 applyEffect(sampler2D cameraTexture, vec2 p, bool thresholdCamera, vec3 cameraThresholdColor) {\n\tvec4 color = vec4(0.0);\n\tif (applyEffectInt > 0 && effectNumber < NEffects) {\n\t\tif(effectNumber == 0) {\n\t\t\tcolor = effectJumpCut(cameraTexture, p, thresholdCamera, cameraThresholdColor);\n\t\t} else if(effectNumber == 1) {\n\t\t\tcolor = effectZoom(cameraTexture, p, thresholdCamera);\n\t\t}\n\t} else {\n\t\tcolor = texture2D(cameraTexture, p);\n\t}\n\treturn  color;\n}\n\nvec4 getFromColor(vec2 uv) {\n\tbool thresholdCamera = camera1ApplyThresholdInt > 0;\n\tbool applyFilter = camera1ApplyFiltersInt > 0;\n    vec4 camera1 = applyEffect(camera1Texture, uv, thresholdCamera, camera1ThresholdColor);\n    vec4 camera1Processed = processCamera(camera1, applyFilter, camera1Hue, camera1Saturation, camera1Brightness, camera1Contrast, thresholdCamera, camera1Threshold, camera1ThresholdColor);\n    return camera1Processed;\n}\n\nvec4 getToColor(vec2 uv) {\n\tbool thresholdCamera = camera2ApplyThresholdInt > 0;\n\tbool applyFilter = camera2ApplyFiltersInt > 0;\n    vec4 camera2 = applyEffect(camera2Texture, uv, thresholdCamera, camera2ThresholdColor);\n    vec4 camera2Processed = processCamera(camera2, applyFilter, camera2Hue, camera2Saturation, camera2Brightness, camera2Contrast, thresholdCamera, camera1Threshold, camera2ThresholdColor);\n    return camera2Processed;\n}\n\n\nvec4 zoomTransition(vec2 uv) {\n\tfloat zoom_quickness = 0.8;\n\tfloat nQuick = clamp(zoom_quickness, 0.2, 1.0);\n\treturn mix(\n\t\tgetFromColor(zoom(uv, smoothstep(0.0, nQuick, cameraSelection))),\n\t\tgetToColor(uv),\n\t\tsmoothstep(nQuick - 0.2, 1.0, cameraSelection)\n\t);\n}\n\nvec4 transitionDirectional(vec2 uv, vec2 direction) {\n\tvec2 p = uv + cameraSelection * sign(direction);\n\tvec2 f = fract(p);\n\treturn mix(\n\t\tgetToColor(f),\n\t\tgetFromColor(f),\n\t\tstep(0.0, p.y) * step(p.y, 1.0) * step(0.0, p.x) * step(p.x, 1.0)\n\t);\n}\n\nvec4 transitionSlice (vec2 p, float count, float smoothness) {\n  float pr = smoothstep(-smoothness, 0.0, p.x - cameraSelection * (1.0 + smoothness));\n  float s = step(pr, fract(count * p.x));\n  return mix(getFromColor(p), getToColor(p), s);\n}\n\nvec4 transitionWaterDrop(vec2 p, float amplitude, float speed) {\n  vec2 dir = p - vec2(.5);\n  float dist = length(dir);\n\n  if (dist > cameraSelection) {\n    return mix(getFromColor( p), getToColor( p), cameraSelection);\n  } else {\n    vec2 offset = dir * sin(dist * amplitude - cameraSelection * speed);\n    return mix(getFromColor( p + offset), getToColor( p), cameraSelection);\n  }\n}\n\n\nfloat wave(int num, float frequency, int bars) {\n  float fn = float(num) * frequency * 0.1 * float(bars);\n  return cos(fn * 0.5) * cos(fn * 0.13) * sin((fn+10.0) * 0.3) / 2.0 + 0.5;\n}\n\nfloat drip(int num, int bars, float dripScale) {\n  return sin(float(num) / float(bars - 1) * 3.141592) * dripScale;\n}\n\nfloat pos(int num, float noise, float frequency, int bars, float dripScale) {\n  return (noise == 0.0 ? wave(num, frequency, bars) : mix(wave(num, frequency, bars), rand(num), noise)) + (dripScale == 0.0 ? 0.0 : drip(num, bars, dripScale));\n}\n\nvec4 transitionBars(vec2 uv, int bars, float amplitude, float noise, float frequency, float dripScale) {\n\n  int bar = int(uv.x * (float(bars)));\n  float scale = 1.0 + pos(bar, noise, frequency, bars, dripScale) * amplitude;\n  float phase = cameraSelection * scale;\n  float posY = uv.y / vec2(1.0).y;\n  vec2 p;\n  vec4 c;\n  if (phase + posY < 1.0) {\n    p = vec2(uv.x, uv.y + mix(0.0, vec2(1.0).y, phase)) / vec2(1.0).xy;\n    c = getFromColor(p);\n  } else {\n    p = uv.xy / vec2(1.0).xy;\n    c = getToColor(p);\n  }\n\n  // Finally, apply the color\n  return c;\n}\n\n\nvec4 transitionPinWheel(vec2 uv, float speed) {\n  \n  vec2 p = uv.xy / vec2(1.0).xy;\n  \n  float circPos = atan(p.y - 0.5, p.x - 0.5) + cameraSelection * speed;\n  float modPos = mod(circPos, 3.1415 / 4.);\n  float signed = sign(cameraSelection - modPos);\n  \n  return mix(getToColor(p), getFromColor(p), step(signed, 0.5));\n  \n}\n\nvec4 transitionAngular (vec2 uv, float startingAngle) {\n  \n  float offset = startingAngle * PI / 180.0;\n  float angle = atan(uv.y - 0.5, uv.x - 0.5) + offset;\n  float normalizedAngle = (angle + PI) / (2.0 * PI);\n  \n  normalizedAngle = normalizedAngle - floor(normalizedAngle);\n\n  return mix(\n    getFromColor(uv),\n    getToColor(uv),\n    step(normalizedAngle, cameraSelection)\n    );\n}\n\nvec4 transitionColorPhase(vec2 uv) {\n\tvec4 fromStep = vec4(0.0, 0.2, 0.4, 0.0);\n\tvec4 toStep = vec4(0.6, 0.8, 1.0, 1.0);\n\n\tvec4 a = getFromColor(uv);\n\tvec4 b = getToColor(uv);\n\treturn mix(a, b, smoothstep(fromStep, toStep, vec4(cameraSelection)));\n}\n\nvec4 transitionCircle(vec2 uv) {\n  \n  vec2 center = vec2(0.5, 0.5);\n  vec3 backColor = vec3(0.1, 0.1, 0.1);\n\n  float distance = length(uv - center);\n  float radius = sqrt(8.0) * abs(cameraSelection - 0.5);\n  \n  if (distance > radius) {\n    return vec4(backColor, 1.0);\n  }\n  else {\n    if (cameraSelection < 0.5) return getFromColor(uv);\n    else return getToColor(uv);\n  }\n}\n\n\nvec2 project (vec2 p, float floating) {\n  return p * vec2(1.0, -1.2) + vec2(0.0, -floating/100.);\n}\n\nbool inBounds (vec2 p) {\n  return all(lessThan(vec2(0.0), p)) && all(lessThan(p, vec2(1.0)));\n}\n\nvec4 bgColor (vec2 p, vec2 pfr, vec2 pto, float reflection, float floating) {\n  vec4 c = vec4(0.0, 0.0, 0.0, 1.0);\n  pfr = project(pfr, floating);\n  // FIXME avoid branching might help perf!\n  if (inBounds(pfr)) {\n    c += mix(vec4(0.0), getFromColor(pfr), reflection * mix(1.0, 0.0, pfr.y));\n  }\n  pto = project(pto, floating);\n  if (inBounds(pto)) {\n    c += mix(vec4(0.0), getToColor(pto), reflection * mix(1.0, 0.0, pto.y));\n  }\n  return c;\n}\n\n// p : the position\n// persp : the perspective in [ 0, 1 ]\n// center : the xcenter in [0, 1] \\ 0.5 excluded\nvec2 xskew (vec2 p, float persp, float center) {\n  float x = mix(p.x, 1.0-p.x, center);\n  return (\n    (\n      vec2( x, (p.y - 0.5*(1.0-persp) * x) / (1.0+(persp-1.0)*x) )\n      - vec2(0.5-distance(center, 0.5), 0.0)\n    )\n    * vec2(0.5 / distance(center, 0.5) * (center<0.5 ? 1.0 : -1.0), 1.0)\n    + vec2(center<0.5 ? 0.0 : 1.0, 0.0)\n  );\n}\n\nvec4 transitionCube(vec2 op) {\n\n  float persp = 0.7;\n  float unzoom = 0.3;\n  float reflection = 0.4;\n  float floating = 3.0;\n\n  float uz = unzoom * 2.0*(0.5-distance(0.5, cameraSelection));\n  vec2 p = -uz*0.5+(1.0+uz) * op;\n  vec2 fromP = xskew(\n    (p - vec2(cameraSelection, 0.0)) / vec2(1.0-cameraSelection, 1.0),\n    1.0-mix(cameraSelection, 0.0, persp),\n    0.0\n  );\n  vec2 toP = xskew(\n    p / vec2(cameraSelection, 1.0),\n    mix(pow(cameraSelection, 2.0), 1.0, persp),\n    1.0\n  );\n  // FIXME avoid branching might help perf!\n  if (inBounds(fromP)) {\n    return getFromColor(fromP);\n  }\n  else if (inBounds(toP)) {\n    return getToColor(toP);\n  }\n  return bgColor(op, fromP, toP, reflection, floating);\n}\n\n\nvec2 project2 (vec2 p) {\n  return p * vec2(1.0, -1.2) + vec2(0.0, -0.02);\n}\n\nvec4 bgColor (vec2 p, vec2 pto, float reflection) {\n  vec4 c = vec4(0.0);\n  pto = project2(pto);\n  if (inBounds(pto)) {\n    c += mix(c, getToColor(pto), reflection * mix(1.0, 0.0, pto.y));\n  }\n  return c;\n}\n\n\nvec4 transitionDoorWay (vec2 p) {\n\n  float reflection = 0.4;\n  float perspective = 0.4;\n  float depth = 3.0;\n\n  const vec4 black = vec4(0.0, 0.0, 0.0, 0.0);\n  const vec2 boundMin = vec2(0.0, 0.0);\n  const vec2 boundMax = vec2(1.0, 1.0);\n\n  vec2 pfr = vec2(-1.), pto = vec2(-1.);\n  float middleSlit = 2.0 * abs(p.x-0.5) - cameraSelection;\n  if (middleSlit > 0.0) {\n    pfr = p + (p.x > 0.5 ? -1.0 : 1.0) * vec2(0.5*cameraSelection, 0.0);\n    float d = 1.0/(1.0+perspective*cameraSelection*(1.0-middleSlit));\n    pfr.y -= d/2.;\n    pfr.y *= d;\n    pfr.y += d/2.;\n  }\n  float size = mix(1.0, depth, 1.-cameraSelection);\n  pto = (p + vec2(-0.5, -0.5)) * vec2(size, size) + vec2(0.5, 0.5);\n  if (inBounds(pfr)) {\n    return getFromColor(pfr);\n  }\n  else if (inBounds(pto)) {\n    return getToColor(pto);\n  }\n  else {\n    return bgColor(p, pto, reflection);\n  }\n}\n\nfloat inHeart (vec2 p, vec2 center, float size) {\n  if (size==0.0) return 0.0;\n  vec2 o = (p-center)/(1.6*size);\n  float a = o.x*o.x+o.y*o.y-0.3;\n  return step(a*a*a, o.x*o.x*o.y*o.y*o.y);\n}\n\nvec4 transitionHeart (vec2 uv) {\n  return mix(\n    getFromColor(uv),\n    getToColor(uv),\n    inHeart(uv, vec2(0.5, 0.4), cameraSelection)\n  );\n}\n\n\nvec4 transitionPixelize(vec2 uv) {\n\n  int steps = 50; // zero disable the stepping\n  ivec2 squaresMin = ivec2(20); // minimum number of squares (when the effect is at its higher level)\n  float d = min(cameraSelection, 1.0 - cameraSelection);\n  float dist = steps>0 ? ceil(d * float(steps)) / float(steps) : d;\n  vec2 squareSize = 2.0 * dist / vec2(squaresMin);\n  \n  \n\n  vec2 p = dist>0.0 ? (floor(uv / squareSize) + 0.5) * squareSize : uv;\n  return mix(getFromColor(p), getToColor(p), cameraSelection);\n}\n\n\nvec4 transitionRotateScaleFade(vec2 uv) {\n  \n  vec2 center = vec2(0.5, 0.5);\n  float rotations = 1.0;\n  float scale = 8.0;\n  vec4 backColor = vec4(0.15, 0.15, 0.15, 1.0);\n\n  vec2 difference = uv - center;\n  vec2 dir = normalize(difference);\n  float dist = length(difference);\n  \n  float angle = 2.0 * PI * rotations * cameraSelection;\n  \n  float c = cos(angle);\n  float s = sin(angle);\n  \n  float currentScale = mix(scale, 1.0, 2.0 * abs(cameraSelection - 0.5));\n  \n  vec2 rotatedDir = vec2(dir.x  * c - dir.y * s, dir.x * s + dir.y * c);\n  vec2 rotatedUv = center + rotatedDir * dist / currentScale;\n  \n  if (rotatedUv.x < 0.0 || rotatedUv.x > 1.0 ||\n      rotatedUv.y < 0.0 || rotatedUv.y > 1.0)\n    return backColor;\n    \n  return mix(getFromColor(rotatedUv), getToColor(rotatedUv), cameraSelection);\n}\n\n\nvec4 transitionCircleCrop(vec2 p) {\n  vec2 ratio2 = vec2(1.0, 1.0 / 0.5);\n  float s = pow(2.0 * abs(cameraSelection - 0.5), 3.0);\n  vec4 bgcolor = vec4(0.0, 0.0, 0.0, 1.0);\n  float dist = length((vec2(p) - 0.5) * ratio2);\n  return mix(\n    cameraSelection < 0.5 ? getFromColor(p) : getToColor(p), // branching is ok here as we statically depend on cameraSelection uniform (branching won't change over pixels)\n    bgcolor,\n    step(s, dist)\n  );\n}\n\nvec4 transitionColorDistance(vec2 p) {\n  float power = 5.0;\n  vec4 fTex = getFromColor(p);\n  vec4 tTex = getToColor(p);\n  float m = step(distance(fTex, tTex), cameraSelection);\n  return mix(\n    mix(fTex, tTex, m),\n    tTex,\n    pow(cameraSelection, power)\n  );\n}\n\nvec4 transitionSwirl(vec2 UV)\n{\n\tfloat Radius = 1.0;\n\n\tfloat T = cameraSelection;\n\n\tUV -= vec2( 0.5, 0.5 );\n\n\tfloat Dist = length(UV);\n\n\tif ( Dist < Radius )\n\t{\n\t\tfloat Percent = (Radius - Dist) / Radius;\n\t\tfloat A = ( T <= 0.5 ) ? mix( 0.0, 1.0, T/0.5 ) : mix( 1.0, 0.0, (T-0.5)/0.5 );\n\t\tfloat Theta = Percent * Percent * A * 8.0 * 3.14159;\n\t\tfloat S = sin( Theta );\n\t\tfloat C = cos( Theta );\n\t\tUV = vec2( dot(UV, vec2(C, -S)), dot(UV, vec2(S, C)) );\n\t}\n\tUV += vec2( 0.5, 0.5 );\n\n\tvec4 C0 = getFromColor(UV);\n\tvec4 C1 = getToColor(UV);\n\n\treturn mix( C0, C1, T );\n}\n\nvec2 offset(float cameraSelection, float x, float theta) {\n  float phase = cameraSelection*cameraSelection + cameraSelection + theta;\n  float shifty = 0.03*cameraSelection*cos(10.0*(cameraSelection+x));\n  return vec2(0, shifty);\n}\nvec4 transitionDreamy(vec2 p) {\n  return mix(getFromColor(p + offset(cameraSelection, p.x, 0.0)), getToColor(p + offset(1.0-cameraSelection, p.x, 3.14)), cameraSelection);\n}\n\n\nfloat Linear_ease(in float begin, in float change, in float duration, in float easeTime) {\n    return change * easeTime / duration + begin;\n}\n\nfloat Exponential_easeInOut(in float begin, in float change, in float duration, in float easeTime) {\n    if (easeTime == 0.0)\n        return begin;\n    else if (easeTime == duration)\n        return begin + change;\n    easeTime = easeTime / (duration / 2.0);\n    if (easeTime < 1.0)\n        return change / 2.0 * pow(2.0, 10.0 * (easeTime - 1.0)) + begin;\n    return change / 2.0 * (-pow(2.0, -10.0 * (easeTime - 1.0)) + 2.0) + begin;\n}\n\nfloat Sinusoidal_easeInOut(in float begin, in float change, in float duration, in float easeTime) {\n    return -change / 2.0 * (cos(PI * easeTime / duration) - 1.0) + begin;\n}\n\n\nvec3 crossFade(in vec2 uv, in float dissolve) {\n    return mix(getFromColor(uv).rgb, getToColor(uv).rgb, dissolve);\n}\n\nvec4 transitionCrossZoom(vec2 uv) {\n\tfloat strength = 0.4;\n    vec2 texCoord = uv.xy / vec2(1.0).xy;\n\n    // Linear interpolate center across center half of the image\n    vec2 center = vec2(Linear_ease(0.25, 0.5, 1.0, cameraSelection), 0.5);\n    float dissolve = Exponential_easeInOut(0.0, 1.0, 1.0, cameraSelection);\n\n    // Mirrored sinusoidal loop. 0->strength then strength->0\n    float strength2 = Sinusoidal_easeInOut(0.0, strength, 0.5, cameraSelection);\n\n    vec3 color = vec3(0.0);\n    float total = 0.0;\n    vec2 toCenter = center - texCoord;\n\n    /* randomize the lookup values to hide the fixed number of samples */\n    float offset = rand(uv);\n\n    for (float t = 0.0; t <= 40.0; t++) {\n        float percent = (t + offset) / 40.0;\n        float weight = 4.0 * (percent - percent * percent);\n        color += crossFade(texCoord + toCenter * percent * strength2, dissolve) * weight;\n        total += weight;\n    }\n    return vec4(color / total, 1.0);\n}\n\n\nfloat Rand(vec2 v) {\n  return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 Rotate(vec2 v, float a) {\n  mat2 rm = mat2(cos(a), -sin(a),\n                 sin(a), cos(a));\n  return rm*v;\n}\nfloat CosInterpolation(float x) {\n  return -cos(x*PI)/2.+.5;\n}\n\nvec4 transitionMosaic(vec2 uv) {\n  int endx = 2;\n  int endy = -1;\n  vec2 p = uv.xy / vec2(1.0).xy - .5;\n  vec2 rp = p;\n  float rpr = (cameraSelection*2.-1.);\n  float z = -(rpr*rpr*2.) + 3.;\n  float az = abs(z);\n  rp *= az;\n  rp += mix(vec2(.5, .5), vec2(float(endx) + .5, float(endy) + .5), POW2(CosInterpolation(cameraSelection)));\n  vec2 mrp = mod(rp, 1.);\n  vec2 crp = rp;\n  bool onEnd = int(floor(crp.x))==endx&&int(floor(crp.y))==endy;\n  if(!onEnd) {\n    float ang = float(int(Rand(floor(crp))*4.))*.5*PI;\n    mrp = vec2(.5) + Rotate(mrp-vec2(.5), ang);\n  }\n  if(onEnd || Rand(floor(crp))>.5) {\n    return getToColor(mrp);\n  } else {\n    return getFromColor(mrp);\n  }\n}\n\nvec4 transitionRadial(vec2 p) {\n  float smoothness = 1.0;\n  vec2 rp = p*2.-1.;\n  return mix(\n    getToColor(p),\n    getFromColor(p),\n    smoothstep(0., smoothness, atan(rp.y,rp.x) - (cameraSelection-.5) * PI * 2.5)\n  );\n}\n\n\nvoid main() {\n\tvec2 uv = vPosition.xy + 0.5;\n\n\tvec4 lyricsBackgroundColor = texture2D(lyricsVideoTexture, vec2(0.0, 0.0));\n\n\tvec2 lyricsPosition = uv - 0.5;\n\tlyricsPosition -= vec2(lyricsPositionX, lyricsPositionY);\n\tlyricsPosition /= lyricsScale;\n\tbool lyricsOutside = abs(lyricsPosition.x) > 0.5 || abs(lyricsPosition.y) > 0.5;\n\tlyricsPosition += 0.5;\n\tvec4 lyricsColor = lyricsOutside ? lyricsBackgroundColor : texture2D(lyricsVideoTexture, lyricsPosition);\n\tvec4 background = texture2D(backgroundVideoTexture, uv);\n\n\tvec4 cameraColor = vec4(0.0);\n\tif(transitionNumber == 0) {\n\t\tcameraColor = zoomTransition(uv);\n\t} else if(transitionNumber == 1) {\n\t\tcameraColor = transitionDirectional(uv, vec2(1.0, 0.0));\n\t} else if(transitionNumber == 2) {\n\t\tcameraColor = transitionDirectional(uv, vec2(0.0, 1.0));\n\t} else if(transitionNumber == 3) {\n\t\tcameraColor = transitionDirectional(uv, vec2(0.5, 0.5));\n\t} else if(transitionNumber == 4) {\n\t\tcameraColor = transitionSlice(uv, 10.0, 0.5);\n\t} else if(transitionNumber == 5) {\n\t\tcameraColor = transitionSlice(uv, 25.0, 1.0);\n\t} else if(transitionNumber == 6) {\n\t\tcameraColor = transitionWaterDrop(uv, 30.0, 30.0);\n\t} else if(transitionNumber == 7) {\n\t\tcameraColor = transitionWaterDrop(uv, 10.0, 60.0);\n\t} else if(transitionNumber == 8) {\n\t\tcameraColor = transitionHeart(uv);\n\t} else if(transitionNumber == 9) {\n\t\tcameraColor = transitionBars(uv, 30, 2.0, 0.1, 0.5, 0.5);\n\t} else if(transitionNumber == 10) {\n\t\tcameraColor = transitionBars(uv, 60, 1.0, 0.5, 0.15, 0.85);\n\t} else if(transitionNumber == 11) {\n\t\tcameraColor = transitionPinWheel(uv, 2.0);\n\t} else if(transitionNumber == 12) {\n\t\tcameraColor = transitionAngular(uv, 90.0);\n\t} else if(transitionNumber == 13) {\n\t\tcameraColor = transitionColorPhase(uv);\n\t} else if(transitionNumber == 14) {\n\t\tcameraColor = transitionCircle(uv);\n\t} else if(transitionNumber == 15) {\n\t\tcameraColor = transitionCube(uv);\n\t} else if(transitionNumber == 16) {\n\t\tcameraColor = transitionDoorWay(uv);\n\t} else if(transitionNumber == 17) {\n\t\tcameraColor = transitionHeart(uv);\n\t}  else if(transitionNumber == 18) {\n\t\tcameraColor = transitionPixelize(uv);\n\t}  else if(transitionNumber == 19) {\n\t\tcameraColor = transitionRotateScaleFade(uv);\n\t}  else if(transitionNumber == 20) {\n\t\tcameraColor = transitionCircleCrop(uv);\n\t}  else if(transitionNumber == 21) {\n\t\tcameraColor = transitionColorDistance(uv);\n\t}  else if(transitionNumber == 22) {\n\t\tcameraColor = transitionSwirl(uv);\n\t}  else if(transitionNumber == 23) {\n\t\tcameraColor = transitionDreamy(uv);\n\t}  else if(transitionNumber == 24) {\n\t\tcameraColor = transitionCrossZoom(uv);\n\t}  else if(transitionNumber == 25) {\n\t\tcameraColor = transitionMosaic(uv);\n\t}  else if(transitionNumber == 26) {\n\t\tcameraColor = transitionRadial(uv);\n\t} else {\n        discard;\n\t}\n\n\tvec4 cameraBackgroundColor = mix(background, cameraColor, cameraColor.a);\n\n\tfloat lyricsDistToBackground = length(lyricsColor.xyz - lyricsBackgroundColor.xyz);\n\tgl_FragColor = lyricsDistToBackground > lyricsThreshold ? lyricsColor : cameraBackgroundColor;\n\t// gl_FragColor = cameraColor;\n}`;"},"lineCount":null}},"error":null,"hash":"5350e82195bdf765716154ee22e365a4","cacheData":{"env":{}}}